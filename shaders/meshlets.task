#version 460

#extension GL_EXT_mesh_shader: require
#extension GL_GOOGLE_include_directive: require

#include "types.glsl"
#include "common.glsl"

layout (local_size_x = kTaskWorkGroups, local_size_y = 1, local_size_z = 1) in;

layout (binding = 1) readonly buffer Meshlets
{
    Meshlet meshlets[];
};

layout (binding = 3) readonly buffer MeshesData
{
    MeshData meshes_data[];
};

layout (binding = 4) readonly buffer MeshesTransforms
{
    MeshTransform meshes_transforms[];
};

layout (binding = 5) readonly buffer DrawMeshIndirects
{
    DrawMeshIndirect draw_mesh_cmds[];
};

layout (binding = 6) buffer FrameCullDataBuffer
{
    FrameCullData frame_cull;
};

layout (push_constant) uniform constants
{
    mat4 vp;
} pc;

shared uint meshlets_count;
taskPayloadSharedEXT MeshletTask meshlet_task;

void main()
{
    uint meshlet_warp = gl_WorkGroupID.x;
    uint meshlet_id = draw_mesh_cmds[gl_DrawID].base_meshlet + meshlet_warp * kTaskWorkGroups + gl_LocalInvocationID.x;

    uint mesh_id = draw_mesh_cmds[gl_DrawID].mesh_id;

    meshlet_task.mesh_id = mesh_id;
    meshlet_task.base_vertex = meshes_data[gl_DrawID].base_vertex;

    meshlets_count = 0;
    barrier();

    vec3 cull_cone_axis = vec3(
    meshlets[meshlet_id].cone_axis[0],
    meshlets[meshlet_id].cone_axis[1],
    meshlets[meshlet_id].cone_axis[2]
    );
    float cull_cutoff = meshlets[meshlet_id].cone_cutoff;

    vec3 sphere_center = vec3(
    meshlets[meshlet_id].sphere_center[0],
    meshlets[meshlet_id].sphere_center[1],
    meshlets[meshlet_id].sphere_center[2]
    );

    float sphere_radius = meshlets[meshlet_id].sphere_radius * meshes_transforms[mesh_id].pos_and_scale.w;

    vec3 view_axis = (frame_cull.view * vec4(quat_rotate_vec3(cull_cone_axis, meshes_transforms[mesh_id].rotation_quat), 0.0F)).xyz;
    vec3 view_center = (frame_cull.view * vec4(transform_vec3(sphere_center, meshes_transforms[mesh_id].pos_and_scale, meshes_transforms[mesh_id].rotation_quat), 1.0F)).xyz;

    bool visible = true;
    visible = GET_BIT(frame_cull.flags, kMeshletConeCullBit) == 0 || dot(view_center, view_axis) < cull_cutoff * length(view_center) + sphere_radius;

    if (GET_BIT(frame_cull.flags, kMeshletFrustumCullBit) == 1)
    {
        visible = visible && view_center.z * frame_cull.frustum[1] - abs(view_center.x) * frame_cull.frustum[0] > -sphere_radius;
        visible = visible && view_center.z * frame_cull.frustum[3] - abs(view_center.y) * frame_cull.frustum[2] > -sphere_radius;
        visible = visible && view_center.z - sphere_radius < -frame_cull.frustum[4] && view_center.z + sphere_radius > -frame_cull.frustum[5];
    }

    if (visible)
    {
        uint idx = atomicAdd(meshlets_count, 1);
        meshlet_task.meshlet_ids[idx] = meshlet_id;
    }

    barrier();
    EmitMeshTasksEXT(meshlets_count, 1, 1);
}
