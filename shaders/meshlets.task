#version 460

#extension GL_EXT_mesh_shader: require
#extension GL_GOOGLE_include_directive: require

#include "types.glsl"
#include "common.glsl"

layout (local_size_x = kTaskWorkGroups, local_size_y = 1, local_size_z = 1) in;

layout (binding = 1) readonly buffer Meshlets
{
    Meshlet meshlets[];
};

layout (binding = 3) readonly buffer MeshesData
{
    MeshData meshes_data[];
};

layout (binding = 4) readonly buffer MeshesTransforms
{
    MeshTransform meshes_transforms[];
};

layout (binding = 5) readonly buffer DrawMeshIndirects
{
    DrawMeshIndirect draw_mesh_cmds[];
};

// FIXME: most of this data is temporary
layout (push_constant) uniform constants
{
    mat4 vp;
    mat4 view;
    uint use_culling; // TODO: use bit flags for debug only?
} pc;

shared uint meshlets_count;
taskPayloadSharedEXT MeshletTask meshlet_task;

bool should_cull(vec3 cone_axis, vec3 center, float radius, float cutoff)
{
    uint mesh_id = draw_mesh_cmds[gl_DrawID].mesh_id;
    vec3 view_axis = (pc.view * vec4(quat_rotate_vec3(cone_axis, meshes_transforms[mesh_id].rotation_quat), 0.0F)).xyz;
    vec3 view_center = (pc.view * vec4(transform_vec3(center, meshes_transforms[mesh_id].pos_and_scale, meshes_transforms[mesh_id].rotation_quat), 1.0F)).xyz;

    return dot(view_center, view_axis) >= cutoff * length(view_center) + (radius * meshes_transforms[mesh_id].pos_and_scale.w);
}

void main()
{
    uint meshlet_warp = gl_WorkGroupID.x;
    uint meshlet_id = draw_mesh_cmds[gl_DrawID].base_meshlet + meshlet_warp * kTaskWorkGroups + gl_LocalInvocationID.x;

    meshlet_task.mesh_id = draw_mesh_cmds[gl_DrawID].mesh_id;
    meshlet_task.base_vertex = meshes_data[gl_DrawID].base_vertex;

    #if USE_CONE_CULLING
    meshlets_count = 0;
    barrier();

    vec3 cull_cone_axis = vec3(
    meshlets[meshlet_id].cone_axis[0],
    meshlets[meshlet_id].cone_axis[1],
    meshlets[meshlet_id].cone_axis[2]
    );
    float cull_cutoff = meshlets[meshlet_id].cone_cutoff;

    vec3 sphere_center = vec3(
    meshlets[meshlet_id].sphere_center[0],
    meshlets[meshlet_id].sphere_center[1],
    meshlets[meshlet_id].sphere_center[2]
    );
    float sphere_radius = meshlets[meshlet_id].sphere_radius;

    bool culled = ((pc.use_culling == 1) && should_cull(cull_cone_axis, sphere_center, sphere_radius, cull_cutoff));
    if (!culled)
    {
        uint idx = atomicAdd(meshlets_count, 1);
        meshlet_task.meshlet_ids[idx] = meshlet_id;
    }

    barrier();
    EmitMeshTasksEXT(meshlets_count, 1, 1);
    #else
    meshlet_task.meshlet_ids[gl_LocalInvocationID.x] = meshlet_id;
    EmitMeshTasksEXT(kTaskWorkGroups, 1, 1);
    #endif
}
