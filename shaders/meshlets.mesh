#version 460
#extension GL_EXT_mesh_shader: require

#include "types.h"

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout (triangles, max_vertices = kMaxVerticesPerMeshlet, max_primitives = kMaxTrianglesPerMeshlet) out;

layout (binding = 0) readonly buffer Vertices
{
    Vertex vertices[];
};

layout (binding = 1) readonly buffer Meshlets
{
    Meshlet meshlets[];
};

layout (push_constant) uniform constants
{
    mat4 vp;
    vec4 sun_pos;
    vec4 view_pos;
} pc;

//out VS_OUT {
//    layout (location = 0) out vec2 uv;
//    layout (location = 1) out vec3 normal;
//    layout (location = 2) out vec3 tangent;
//    layout (location = 3) out vec3 bitangent;
//    layout (location = 4) out vec4 world_pos;
//    layout (location = 5) out vec4 sun_pos;
//} vs_out[];

layout (location = 0) out vec3 normal[];

void main()
{
    uint meshlet_id = gl_WorkGroupID.x;
    uint tid = gl_LocalInvocationIndex;
    uint workgroup_size = gl_WorkGroupSize.x;

    uint vertex_count = uint(meshlets[meshlet_id].vertices_count);
    uint triangle_count = uint(meshlets[meshlet_id].triangles_count);

    SetMeshOutputsEXT(vertex_count, triangle_count);

    // Each thread processes multiple vertices, striding by workgroup size
    for (uint i = tid; i < vertex_count; i += workgroup_size)
    {
        Vertex v = vertices[meshlets[meshlet_id].vertices[i]];
        normal[i] = vec3(v.nx, v.ny, v.nz);
        gl_MeshVerticesEXT[i].gl_Position = pc.vp * vec4(v.px, v.py, v.pz, 1.0F);
    }

    // Same for triangles
    for (uint i = tid; i < triangle_count; i += workgroup_size)
    {
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(
            meshlets[meshlet_id].indices[i * 3 + 0],
            meshlets[meshlet_id].indices[i * 3 + 1],
            meshlets[meshlet_id].indices[i * 3 + 2]
        );
    }
}
