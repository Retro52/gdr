#version 460

#extension GL_EXT_mesh_shader: require
#extension GL_GOOGLE_include_directive: require

#include "types.glsl"
#include "common.glsl"

// FIXME: for whatever reason passing 94 (our constant) is illegal for max_primitives, investigate?
layout (local_size_x = kMeshWorkGroups, local_size_y = 1, local_size_z = 1) in;
layout (triangles, max_vertices = 64, max_primitives = 96) out;

layout (binding = 0) readonly buffer Vertices
{
    Vertex vertices[];
};

layout (binding = 1) readonly buffer Meshlets
{
    Meshlet meshlets[];
};

layout (binding = 2) readonly buffer MeshletIndices
{
    uint8_t meshlets_indices[];
};

layout (binding = 2) readonly buffer MeshletVertices
{
    uint meshlets_vertices[];
};

layout (binding = 4) readonly buffer MeshesTransforms
{
    MeshTransform meshes_transforms[];
};

// FIXME: most of this data is temporary
layout (push_constant) uniform constants
{
    mat4 vp;
    mat4 view;
} pc;

out VS_OUT {
    layout (location = 0) out vec2 uv;
    layout (location = 1) out vec3 normal;
    layout (location = 2) out vec3 tangent;
    layout (location = 3) out vec3 bitangent;
    layout (location = 4) out vec4 world_pos;
#if VISUALIZE_MESHLETS
    layout (location = 5) out flat uint meshlet_id;
#endif
} vs_out[];

taskPayloadSharedEXT MeshletTask meshlet_task;

void main()
{
    const uint t_idx = gl_LocalInvocationID.x;
    const uint m_idx = meshlet_task.meshlet_ids[gl_WorkGroupID.x];

    const uint vertex_count = uint(meshlets[m_idx].vertices_count);
    const uint triangle_count = uint(meshlets[m_idx].triangles_count);

    const uint base_vertex = meshlets[m_idx].data_offset / 4;
    const uint base_index  = meshlets[m_idx].data_offset + vertex_count * 4;

    SetMeshOutputsEXT(vertex_count, triangle_count);

    // Each thread processes multiple vertices, striding by workgroup size
    for (uint i = t_idx; i < vertex_count; i += gl_WorkGroupSize.x)
    {
        const uint vid = meshlet_task.base_vertex + meshlets_vertices[base_vertex + i];

        vec3 local_pos = vec3(vertices[vid].px, vertices[vid].py, vertices[vid].pz);
        vs_out[i].world_pos = vec4(transform_vec3(local_pos, meshes_transforms[meshlet_task.draw_id].pos_and_scale, meshes_transforms[meshlet_task.draw_id].rotation_quat), 1.0);
        vs_out[i].normal = vec3(vertices[vid].nx, vertices[vid].ny, vertices[vid].nz);

#if VISUALIZE_MESHLETS
        vs_out[i].meshlet_id = meshlet_task.meshlet_ids[gl_WorkGroupID.x];
#endif

#if 0
        vs_out[i].uv = vec2(vertices[vid].ux, vertices[vid].uy);
        vs_out[i].tangent = vec3(vertices[vid].tx, vertices[vid].ty, vertices[vid].tz);
        vs_out[i].bitangent = cross(vs_out[i].tangent, vs_out[i].normal);
#endif

        gl_MeshVerticesEXT[i].gl_Position = pc.vp * vs_out[i].world_pos;
    }

    // Same for triangles
    for (uint i = t_idx; i < triangle_count; i += gl_WorkGroupSize.x)
    {
        const uint iid = base_index + i * 3;
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(
            meshlets_indices[iid + 0],
            meshlets_indices[iid + 1],
            meshlets_indices[iid + 2]
        );
    }
}
