#version 460

#extension GL_EXT_mesh_shader: require
#extension GL_GOOGLE_include_directive: require

#include "types.glsl"

// FIXME: for whatever reason passing 94 (our constant) is illegal for max_primitives, investigate?
layout (local_size_x = kMeshWorkGroups, local_size_y = 1, local_size_z = 1) in;
layout (triangles, max_vertices = 64, max_primitives = 96) out;

layout (binding = 0) readonly buffer Vertices
{
    Vertex vertices[];
};

layout (binding = 1) readonly buffer Meshlets
{
    Meshlet meshlets[];
};

// FIXME: using 2 buffers seems slower than huge meshlets
// I think it would make sense to merge them into the single one
layout (binding = 2) readonly buffer MeshletIndices
{
    uint8_t meshlets_indices[];
};

layout (binding = 3) readonly buffer MeshletVertices
{
    uint meshlets_vertices[];
};

layout (push_constant) uniform constants
{
    mat4 vp;
    vec4 sun_pos;
    vec4 view_pos;
    vec4 view_dir;
} pc;

out VS_OUT {
    layout (location = 0) vec2 uv;
    layout (location = 1) vec3 normal;
    layout (location = 2) vec3 tangent;
    layout (location = 3) vec3 bitangent;
    layout (location = 4) vec4 world_pos;
#if VISUALIZE_MESHLETS
    layout (location = 5) flat uint meshlet_id;
    layout (location = 6) flat uint triangle_id;
#endif
} vs_out[];

taskPayloadSharedEXT MeshletTask meshlet_task;

void main()
{
#if USE_TASK_SHADER
    uint t_idx = gl_LocalInvocationID.x;
    uint m_idx = meshlet_task.meshlet_ids[gl_WorkGroupID.x];
#else
    uint m_idx = gl_WorkGroupID.x;
    uint t_idx = gl_LocalInvocationIndex;
#endif
    uint vertex_count = uint(meshlets[m_idx].vertices_count);
    uint triangle_count = uint(meshlets[m_idx].triangles_count);

    SetMeshOutputsEXT(vertex_count, triangle_count);

    // Each thread processes multiple vertices, striding by workgroup size
    for (uint i = t_idx; i < vertex_count; i += kMeshWorkGroups)
    {
#if 0
        Vertex v = vertices[meshlets[m_idx].vertices[i]];
#else
        uint vid = meshlets[m_idx].vertex_offset + i;
        Vertex v = vertices[meshlets_vertices[vid]];
#endif

#if VISUALIZE_MESHLETS
        vs_out[i].triangle_id = t_idx;
        vs_out[i].meshlet_id = m_idx;
#endif

        vs_out[i].uv = vec2(v.ux, v.uy);
        vs_out[i].normal = vec3(v.nx, v.ny, v.nz);
        vs_out[i].tangent = vec3(v.tx, v.ty, v.tz);
        vs_out[i].bitangent = cross(vs_out[i].tangent, vs_out[i].normal);
        vs_out[i].world_pos = vec4(v.px, v.py, v.pz, 1.0);

        gl_MeshVerticesEXT[i].gl_Position = pc.vp * vs_out[i].world_pos;
    }

    // Same for triangles
    for (uint i = t_idx; i < triangle_count; i += kMeshWorkGroups)
    {
    #if 0
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(
            meshlets[m_idx].indices[i * 3 + 0],
            meshlets[m_idx].indices[i * 3 + 1],
            meshlets[m_idx].indices[i * 3 + 2]
        );
    #else
        uint iid = meshlets[m_idx].index_offset + i * 3;
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(
            meshlets_indices[iid + 0],
            meshlets_indices[iid + 1],
            meshlets_indices[iid + 2]
        );
    #endif
    }
}
