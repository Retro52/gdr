#version 460

#extension GL_GOOGLE_include_directive: require

#include "types.glsl"
#include "common.glsl"

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) readonly buffer MeshesData
{
    MeshData meshes_data[];
};

layout (binding = 1) readonly buffer MeshesTransforms
{
    MeshTransform meshes_transforms[];
};

layout (binding = 2) writeonly buffer DrawIndexedIndirects
{
    DrawIndexedIndirect draw_indirect_cmds[];
};

layout (push_constant) uniform constants
{
    vec4 frustum[6];
    uint draw_count;
    uint base_lod;
} pc;

void main()
{
    uint mi = gl_WorkGroupID.x;
    uint ti = gl_LocalInvocationID.x;

    uint idx = mi * gl_WorkGroupSize.x + ti;
    if (idx < pc.draw_count)
    {
        vec3 center = vec3(meshes_data[idx].center[0], meshes_data[idx].center[1], meshes_data[idx].center[2]) + meshes_transforms[idx].pos_and_scale.xyz;
        float radius = meshes_data[idx].radius * meshes_transforms[idx].pos_and_scale.w;

        bool visible = true;
        for (int i = 0; i < 6; ++i)
            visible = visible && (dot(pc.frustum[i], vec4(center, 1)) + radius) >= 0;

        draw_indirect_cmds[idx].instance_count = 1;
        draw_indirect_cmds[idx].first_instance = 0;
        draw_indirect_cmds[idx].vertex_offset = int(meshes_data[idx].base_vertex);

        LODData selected_lod = meshes_data[idx].lod_array[min(pc.base_lod, meshes_data[idx].lod_count - 1)];

        draw_indirect_cmds[idx].first_index = selected_lod.base_index;
        draw_indirect_cmds[idx].index_count = visible ? selected_lod.indices_count : 0;
    }
}
