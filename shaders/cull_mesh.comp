#version 460

#extension GL_GOOGLE_include_directive: require

#include "types.glsl"
#include "common.glsl"

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) readonly buffer MeshesData
{
    MeshData meshes_data[];
};

layout (binding = 1) readonly buffer MeshesTransforms
{
    MeshTransform meshes_transforms[];
};

layout (binding = 2) buffer MeshesDrawCommandsCount
{
    uint draw_commands_count;
};

layout (binding = 3) writeonly buffer DrawIndexedIndirects
{
    DrawIndexedIndirect draw_indirect_cmds[];
};

layout (push_constant) uniform constants
{
    vec4 frustum[6];
    vec3 camera_pos;
    uint draw_count;
    uint enable_culling;
    uint enable_lods;
} pc;

void main()
{
    uint mi = gl_WorkGroupID.x;
    uint ti = gl_LocalInvocationID.x;

    uint idx = mi * gl_WorkGroupSize.x + ti;
    if (idx < pc.draw_count)
    {
        vec3 center = transform_vec3(vec3(meshes_data[idx].center[0], meshes_data[idx].center[1], meshes_data[idx].center[2]), meshes_transforms[idx].pos_and_scale, meshes_transforms[idx].rotation_quat);
        float radius = meshes_data[idx].radius * meshes_transforms[idx].pos_and_scale.w;

        bool visible = true;
        for (int i = 0; i < 6; ++i)
            visible = visible && (dot(pc.frustum[i], vec4(center, 1)) + radius) >= 0;

        if (visible || pc.enable_culling == 0)
        {
            const float kLODFactor = 10.0F;
            uint lod_base = min(meshes_data[idx].lod_count - 1, max(0, uint(floor(log2((length(pc.camera_pos.xyz - center) + kLODFactor) / kLODFactor)))));
            lod_base = pc.enable_lods == 0 ? 0 : lod_base;
            LODData selected_lod = meshes_data[idx].lod_array[lod_base];

            uint dci = atomicAdd(draw_commands_count, 1);

            draw_indirect_cmds[dci].instance_count = 1;
            draw_indirect_cmds[dci].first_instance = 0;
            draw_indirect_cmds[dci].vertex_offset = int(meshes_data[idx].base_vertex);

            draw_indirect_cmds[dci].mesh_id = idx;
            draw_indirect_cmds[dci].first_index = selected_lod.base_index;
            draw_indirect_cmds[dci].index_count = selected_lod.indices_count;
        }
    }
}
