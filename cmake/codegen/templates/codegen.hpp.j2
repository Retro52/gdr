// Auto-generated by codegen.py
// No point in editing it by hand tbh

#pragma once

#include <imgui.h>

#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/quaternion.hpp>

#include <cstring>
{% if opts.generate_type_list %}
#include <tuple>
{% endif %}
{% for inc in opts.includes %}
#include {{ inc if inc.startswith('<') or inc.startswith('"') else '"%s"' % inc }}
{% endfor %}

namespace codegen
{
{% if opts.generate_names %}
{% for struct in structs %}
template<>
constexpr std::string_view type_name<{{ struct.full_name }}> = "{{ struct.display_name or struct.name | prettify }}";
{% endfor %}

{% endif %}
// Draw functions
{% for struct in structs %}
inline bool draw({{ struct.full_name }}& {{ opts.param_name }})
{
    bool modified = false;
{% set visible = struct.fields | rejectattr('hidden') | list %}
{% if not visible %}
    ImGui::TextDisabled("(no fields)");
{% else %}
{% for fld in visible %}
{% set widget = fld | widget_code(config) %}
{% if widget %}
{% if fld.readonly %}
    {{ widget }};
{% else %}
    modified |= {{ widget }};
{% endif %}
{% endif %}
{% endfor %}
{% endif %}
    return modified;
}

{% endfor %}
{% for struct in structs %}
inline bool draw_header({{ struct.full_name }}& {{ opts.param_name }}, ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_DefaultOpen)
{
    if (ImGui::CollapsingHeader("{{ struct.display_name or struct.name | prettify }}", flags))
    {
        ImGui::Indent();
        bool result = draw({{ opts.param_name }});
        ImGui::Unindent();
        return result;
    }

    return false;
}
{% endfor %}
}

{% if opts.generate_type_list %}
namespace codegen::{{ opts.namespace }}
{
// Type list for template metaprogramming
using {{ opts.type_list_name }} = std::tuple<{{ structs | map(attribute='full_name') | join(', ') }}>;

inline constexpr std::size_t type_count = {{ structs | length }};

template<std::size_t I>
using type_at = std::tuple_element_t<I, {{ opts.type_list_name }}>;

template<typename F, std::size_t... Is>
constexpr void for_each_type_impl(F&& f, std::index_sequence<Is...>)
{
    (f.template operator()<type_at<Is>>(), ...);
}

template<typename F>
constexpr void for_each_type(F&& f)
{
    for_each_type_impl(std::forward<F>(f), std::make_index_sequence<type_count>{});
}
}
{% endif %}
